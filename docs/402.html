<html>
<head>
<title>How to Setup private DNS server on ubuntu 20.04 - Eldernode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在ubuntu 20.04 - Eldernode上设置专用DNS服务器</h1>
<blockquote>原文：<a href="https://blog.eldernode.com/private-dns-server-on-ubuntu-20-04/#0001-01-01">https://blog.eldernode.com/private-dns-server-on-ubuntu-20-04/#0001-01-01</a></blockquote><div><div class="blog-details">                                  <img data-lazyloaded="1" src="../Images/ac7518b1020312e1055b85be10c7d20e.png" data-src="https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04.png" class="img-fluid mb-3 shadow-sm round-10 wp-post-image" alt="Setup private DNS server on ubuntu 20.04" decoding="async" data-srcset="https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04.png 2069w, https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04-300x164.png 300w, https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04-1024x561.png 1024w, https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04-768x421.png 768w, https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04-1536x842.png 1536w, https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04-2048x1122.png 2048w" data-sizes="(max-width: 2069px) 100vw, 2069px" data-original-src="https://blog.eldernode.com/wp-content/uploads/2020/11/Setup-private-DNS-server-on-ubuntu-20.04.png"/><p>服务器配置管理讨论的一个重要部分是通过设置适当的“域名系统”(DNS)，提供一种通过名称检查网络连接和IP地址的简单方法。使用<a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name"> FQDN </a>代替IP地址来指代网络中的地址，使得配置服务和应用更加容易，并且增加了存储配置文件的能力。为专用网络设置个人DNS是改善服务器管理的一个好方法。在这篇文章中，我们试图完全教你如何<strong>在ubuntu 20.04 </strong>上设置一个私有DNS服务器。如果需要购买<a href="http://eldernode.com/ubuntu-vps/" target="_blank" rel="noopener noreferrer"> Ubuntu VPS </a>服务器，可以在<a href="https://eldernode.com/" target="_blank" rel="noopener noreferrer"> Eldernode </a>中看到可用的包。</p><h2><span class="ez-toc-section" id="Setup_private_DNS_server_on_ubuntu_2004"/>在ubuntu 20.04上设置私有DNS服务器<span class="ez-toc-section-end"/></h2><p>在本文中，我们将了解如何在<a href="https://blog.eldernode.com/tag/ubuntu/" target="_blank" rel="noopener noreferrer"> Ubuntu </a> 20.04上使用服务器名称软件(BIND)设置内部DNS服务器。您的客户端服务器可以使用此名称服务器来解析主机名称和私有IP地址。这提供了一种集中管理内部主机名称和私有IP地址的方式，当您需要将工作环境扩展到多台主机时，这一点非常重要。跟随我们继续这篇文章，阅读<strong>教程在ubuntu 20.04 </strong>上设置私有DNS服务器。</p><h3><span class="ez-toc-section" id="Prerequisites_for_Setup_private_DNS_server_on_ubuntu_2004"/>在ubuntu 20.04上设置私有DNS服务器的先决条件<span class="ez-toc-section-end"/></h3><p>要学习本教程，您必须具备以下基础设施。请注意，所有服务器必须位于同一个数据中心，并在它们之间启用专用网络:</p><p><strong>–</strong>一台新安装了Ubuntu 20.04版本的服务器，作为主DNS服务器，名为ns1</p><p><strong>–</strong>第二台Ubuntu 20.04服务器作为辅助DNS服务器，名为ns2(推荐)。</p><p><strong>–</strong>同一数据中心内将使用DNS服务器的其他服务器。</p><p><em> <strong>注意:</strong> </em>在这些额外的服务器上，必须通过sudo用户配置访问权限，并且必须使用防火墙。</p><h4><span class="ez-toc-section" id="Sample_infrastructures_and_goals_in_Setup_private_DNS_server_on_ubuntu_2004"/>在ubuntu 20.04上设置专用DNS服务器的示例基础设施和目标<span class="ez-toc-section-end"/></h4><p>鉴于本文的目的，以下是我们的一些假设:</p><p><strong> 1。</strong>我们有两台服务器将用作我们的名称服务器。在本文中，我们将这些服务器称为<strong> ns1 </strong>和<strong> ns2 </strong>。</p><p><strong> 2。</strong>我们有另外两台客户端服务器将使用我们正在创建的DNS基础设施。这些服务器被称为<strong>主机1 </strong>和<strong>主机2 </strong>。当然，您可以向这个基础设施中添加任意数量的服务器。</p><p><strong> 3。</strong>所有这些服务器都位于一个数据中心。我们假设这个数据中心的名称是<strong> nyc3 </strong>。</p><p><strong> 4。所有这些服务器都有专用网络，位于子网<strong> 10.128.0.0。/16 </strong>。当然，您必须根据服务器的规格来更改这些内容。</strong></p><p><strong> 5。</strong>所有服务器都连接到位于“【example.com】T2域的项目。因为我们的DNS系统是完全内部私有的，所以不需要购买域名。但是，使用域有助于防止对公共可路由域的干扰。</p><p><em> <strong>注:</strong> </em>根据上述假设，很明显，名为“nyc3.example.com”的命名方案适用于指代私有子网或区域。因此，主机1的FQDN应该是host1.nyc3.example.com。</p><p>请注意，您现有的设置可能有所不同；但是，为说明如何配置DNS服务器而提供的示例字母和IP地址是完全运行的内部DNS的示例。您可以通过替换现有环境中的主机名和专用IP地址来轻松使用这些设置。如果您使用多个数据中心，您可以在每个相应的数据中心内创建一个内部DNS。</p><h2><span class="ez-toc-section" id="How_to_install_BIND_on_DNS_servers"/>如何在DNS服务器上安装BIND<span class="ez-toc-section-end"/></h2><p>请注意，在本教程中，<strong>红色</strong>中突出显示的项目通常是变量，您应该根据服务器的规格用值来替换它们。例如，如果你看到一个变量是host1.nyc3.example.com的T2，你必须输入你的服务器的FQDN。类似地，用您的服务器的IP地址替换您的<strong> host1_private_IP </strong>。</p><p>通过输入以下命令，更新名为<strong> ns1 </strong>和<strong> ns2 </strong>的两个DNS服务器上的apt包:</p><pre class=""><code class="language-bash">sudo apt-get update</code></pre><p>现在使用以下命令安装BIND:</p><pre class=""><code class="language-bash">sudo apt-get install bind9 bind9utils bind9-doc</code></pre><h3><span class="ez-toc-section" id="Learn_how_to_set_BIND_in_IPv4_mode"/>了解如何在IPv4模式下设置绑定<span class="ez-toc-section-end"/></h3><p>您必须设置绑定到IPv4才能继续，因为我们的专用网络只使用IPv4。在两台服务器上，通过输入以下命令编辑默认的bind9设置:</p><pre class=""><code class="language-bash">sudo nano /etc/default/bind9</code></pre><p>将值“<strong> -4 </strong>”添加到选项参数的末尾。事情是这样的:</p><pre class=""><code class="language-bash">...    OPTIONS="-u bind <span>-4</span>"</code></pre><p>完成后，<strong>保存</strong>，<strong>关闭</strong>文件。然后重新启动BIND以使更改生效:</p><pre class=""><code class="language-bash">sudo systemctl restart bind9</code></pre><p>既然已经安装了BIND，就可以配置主DNS服务器了。</p><h2><span class="ez-toc-section" id="How_to_configure_the_main_DNS_server"/>如何配置主DNS服务器<span class="ez-toc-section-end"/></h2><p>绑定配置由几个文件组成，所有这些文件都包含在名为<strong> named.conf </strong>的原始配置文件中。这些文件的名称以名为的<strong>开头，因为这是BIND运行的进程的名称。“域名守护程序”的缩写。我们从配置选项文件开始。</strong></p><h3><span class="ez-toc-section" id="How_to_configure_the_Options_file_on_the_DNS_server"/>如何在DNS服务器上配置选项文件<span class="ez-toc-section-end"/></h3><p>在<strong> ns1 </strong>服务器上打开<strong> named.conf.options </strong>文件进行编辑:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/named.conf.options</code></pre><p>在选项块上方，创建一个名为“trusted”的新ACL。</p><p><em> <strong>注:</strong> </em> ACL代表“访问控制列表”。</p><p>这是我们定义允许返回DNS查询的客户端列表的地方。此列表包括您在同一个ns1数据中心拥有的服务器。使用我们之前介绍的示例中的私有IP地址，我们将ns1、ns2、host1和hst2添加到可信客户端列表中:</p><pre class=""><code class="language-bash">acl "trusted" {          <span>10.128.10.11;</span>    # ns1 - can be set to localhost          <span>10.128.20.12;</span>    # ns2          <span>10.128.100.101;</span>  # host1          <span>10.128.200.102;</span>  # host2  };    options {            . . .</code></pre><p>一旦创建了可信DNS客户端列表，您需要编辑选项块。现在该块的开头如下:</p><pre class=""><code class="language-bash">        . . .  };    options {          directory "/var/cache/bind";          . . .  }</code></pre><p>在目录下添加突出显示的配置行，并替换ns1服务器的IP地址。所以应该是这样的:</p><pre class=""><code class="language-bash">        . . .    };    options {          directory "/var/cache/bind";            <span>recursion yes</span>;                 # enables resursive queries          <span>allow-recursion { trusted; }</span>;  # allows recursive queries from "trusted" clients          <span>listen-on { 10.128.10.11; }</span>;   # ns1 private IP address - listen on private network only          <span>allow-transfer { none; }</span>;      # disable zone transfers by default            <span>forwarders {                  8.8.8.8;                  8.8.4.4;          };</span>            . . .  };</code></pre><p>完成后，保存并关闭named.conf.options文件。上述配置指定只有您的可信服务器(即可信服务器)可以查询外部域的DNS服务器。</p><p>接下来，我们配置本地文件来指定DNS区域。</p><h3><span class="ez-toc-section" id="Learn_how_to_configure_a_local_file"/>了解如何配置本地文件<span class="ez-toc-section-end"/></h3><p>在ns1服务器上打开named.conf.local文件进行编辑:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/named.conf.local</code></pre><p>这个文件应该只有一些注释。在这个文件中，我们指定了正向和反向区域。DNS区域专用于管理和定义DNS记录。因为我们的域在“<strong>nyc3.example.com</strong>”子域内，我们将把它作为我们的转发区域。由于私有IP地址都在IP 10.128.0.0/16，所以我们设置了一个反向区域，在这个范围内定义反向搜索。</p><p>使用以下命令添加转发区域。请确保替换您的区域名称，并在允许传输目录中添加辅助DNS服务器的专用IP地址:</p><pre class=""><code class="language-bash">zone "<span>nyc3.example.com</span>" {      type master;      file "/etc/bind/zones/db.<span>nyc3.example.com</span>"; # zone file path      allow-transfer { <span>10.128.20.12</span>; };           # ns2 private IP address - secondary  };</code></pre><p>假设专用子网是10.128.0.0/16，您可以通过添加以下命令来创建一个反向区域。请注意，我们的反向区域字母以128.10开始，这是反向的10.128:</p><pre class=""><code class="language-bash">    . . .  };    zone "<span>128.10</span>.in-addr.arpa" {      type master;      file "/etc/bind/zones/db.<span>10.128</span>";  # 10.128.0.0/16 subnet      allow-transfer {<span> 10.128.20.12</span>; };  # ns2 private IP address - secondary  };</code></pre><p>如果您的服务器分布在多个子网中；但都在同一个数据中心；您需要确保为每个单独的子网创建一个额外的区域和一个区域文件。当您编辑完所有想要的区域后，<strong>保存</strong>并<strong>关闭</strong>名为<strong>的. conf.local </strong>文件。</p><p>既然在BIND中指定了区域，我们需要创建相应的正向和反向区域文件。</p><h3><span class="ez-toc-section" id="Learn_how_to_create_a_forward_zone_file"/>了解如何创建转发区域文件<span class="ez-toc-section-end"/></h3><p>转发区域文件是存储DNS记录用于转发DNS检查的地方。这意味着，例如，当DNS收到“<strong>host1.nyc3.example.com</strong>”的名称查询时，它会在转发区域文件中查找相应的IP地址以解析host1。</p><p>首先，我们创建一个目录来存放我们的区域文件。根据<strong> named.conf.local </strong>配置，这个位置应该是<strong> etc/bind/zones/ </strong>:</p><pre class=""><code class="language-bash">sudo mkdir /etc/bind/zones</code></pre><p>现在，我们基于<strong> db.local </strong>示例区域文件设计我们的前向区域文件。根据以下命令将其复制到适当的位置:</p><pre class=""><code class="language-bash">sudo cp /etc/bind/db.local /etc/bind/zones/db.<span>nyc3.example.com</span></code></pre><p>现在我们编辑我们的转发文件:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/zones/db.nyc3.example.com</code></pre><p>最初，该文件如下所示:</p><pre class=""><code class="language-bash">$TTL    604800  @       IN      SOA     localhost. root.localhost. (                                2         ; Serial                           604800         ; Refresh                            86400         ; Retry                          2419200         ; Expire                           604800 )       ; Negative Cache TTL  ;  @       IN      NS      localhost.      ; delete this line  @       IN      A       127.0.0.1       ; delete this line  @       IN      AAAA    ::1             ; delete this line</code></pre><p>第一步是编辑SOA记录。因此，我们将FQDN服务器ns1替换为localhost，然后用admin.nyc3.example.com替换root.localhost。每次编辑区域文件时，都必须在重新启动命名进程之前增加其序列号。我们将该值增加到3，因此它看起来像这样:</p><pre class=""><code class="language-bash">@       IN      SOA     <span>ns1.nyc3.example.com. admin.nyc3.example.com</span>. (                                3         ; Serial                                  . . .</code></pre><p>然后我们删除文件末尾的三条记录(在SOA之后)。</p><p><em> <strong>注意:</strong> </em>如果您不确定要删除哪些行，请务必在上面的“<strong>删除此行</strong>”部分中指定。</p><p>在服务器记录文件的末尾，添加以下行的名称。请确保用您自己的值替换这些项目。第二列也表明这些是NS记录:</p><pre class=""><code class="language-bash">. . .    ; name servers - NS records      IN      NS      ns1.<span>nyc3.example.com</span>.      IN      NS      ns2.<span>nyc3.example.com</span>.</code></pre><p>现在，将记录A添加到属于该分区的主机中。这包括所有我们希望以“<strong>nyc3.example.com</strong>”结尾的服务器。请注意，您必须替换所需的私有IP地址和IP地址。</p><p>我们已经使用专用IP地址和本指南中指定的地址为ns1、ns2、主机1和主机2添加了记录:</p><pre class=""><code class="language-bash">. . .    ; name servers - A records  ns1.<span>nyc3.example.com</span>.          IN      A       <span>10.128.10.11</span>  ns2.<span>nyc3.example.com</span>.          IN      A       <span>10.128.20.12</span>    ; 10.128.0.0/16 - A records  host1.<span>nyc3.example.com</span>.        IN      A      <span>10.128.100.101</span>  host2.<span>nyc3.example.com</span>.        IN      A      <span>10.128.200.102</span></code></pre><p><strong>保存</strong>db.nyc3.example.com的<strong>文件并退出。最终的前向区域文件示例看起来像这样:</strong></p><pre class=""><code class="language-bash">$TTL    604800  @       IN      SOA     <span>ns1.nyc3.example.com. admin.nyc3.example.com</span>. (                    3     ; Serial               604800     ; Refresh                86400     ; Retry              2419200     ; Expire               604800 )   ; Negative Cache TTL  ;  ; name servers - NS records       IN      NS     <span> ns1.nyc3.example.com</span>.       IN      NS      <span>ns2.nyc3.example.com</span>.    ; name servers - A records  <span>ns1.nyc3.example.com</span>.          IN      A       <span>10.128.10.11</span>  <span>ns2.nyc3.example.com</span>.          IN      A       <span>10.128.20.12</span>    ; 10.128.0.0/16 - A records  host1.<span>nyc3.example.com</span>.        IN      A      <span>10.128.100.101</span>  host2.<span>nyc3.example.com</span>.        IN      A      <span>10.128.200.102</span></code></pre><p>现在让我们配置反向区域文件:</p><h3><span class="ez-toc-section" id="How_to_create_Reverse_Zone_file_s"/>如何创建反向区域文件<span class="ez-toc-section-end"/></h3><p>定义DNS PTR记录的反向区域用于响应反向DNS查询。也就是说，当DNS接收到基于<strong> 10.128.100.101 </strong>的查询时，例如，它在反向区域文件中查找相应的FQDN，在这种情况下是“【host1.nyc3.example.com】T3”。</p><p>在ns1服务器上，我们为named.conf.local文件中指定的每个反向区域创建一个反向区域文件。反向区域文件基于样本区域文件<strong> db.127 </strong>创建。使用以下命令将其复制到适当的位置。请确保您的反转文件的名称与反转区域的定义相匹配:</p><pre class=""><code class="language-bash">sudo cp /etc/bind/db.127 /etc/bind/zones/db.<span>10.128</span></code></pre><p>编辑对应于在<strong> named.conf.local </strong>中定义的反转区域的反转区域文件:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/zones/db.<span>10.128</span></code></pre><p>最初，该文件如下所示:</p><pre class=""><code class="language-bash">$TTL    604800  @       IN      SOA     localhost. root.localhost. (                                1         ; Serial                           604800         ; Refresh                            86400         ; Retry                          2419200         ; Expire                           604800 )       ; Negative Cache TTL  ;  @       IN      NS      localhost.      ; delete this line  1.0.0   IN      PTR     localhost.      ; delete this line</code></pre><p>与forward zone文件编辑方法一样，我们需要更改<strong> SOA记录</strong>，并将序列号值增加1。该文件如下所示:</p><pre class=""><code class="language-bash">@       IN      SOA     <span>ns1.nyc3.example.com. admin.nyc3.example.com</span>. (                                3         ; Serial                                  . . .</code></pre><p>现在我们编辑文件末尾的两条记录(在SOA记录之后)。如果不确定要删除哪些行；在上面的部分中，这些行标有注释“删除此行”。在文件的底部，用下面几行添加您的名称服务器。一定要把名字换掉。另请注意，第二列指定这些是NS记录:</p><pre class=""><code class="language-bash">. . .    ; name servers - NS records        IN      NS      <span>ns1.nyc3.example.com</span>.        IN      NS      <span>ns2.nyc3.example.com</span>.</code></pre><p>然后，为其IP地址在子网文件区域中被编辑的所有服务器添加PTR记录。</p><p>在我们看到的示例中，这些主机包括所有主机，因为它们都位于子网10.128.0.0/16中。请注意，第一列至少包含了服务器私有IP地址的两个反向部分。请确保替换您的私人信件和IP地址:</p><pre class=""><code class="language-bash">. . .    ; PTR Records  11.10   IN      PTR     ns1.<span>nyc3.example.com</span>.    ; 10.128.10.11  12.20   IN      PTR     ns2.<span>nyc3.example.com</span>.    ; 10.128.20.12  101.100 IN      PTR     <span>host1.nyc3.example.com</span>.  ; 10.128.100.101  102.200 IN      PTR     <span>host2.nyc3.example.com</span>.  ; 10.128.200.102</code></pre><p><strong>保存</strong>反向区域文件并退出。如果您需要添加其他反向区域文件，也对它们重复上述步骤。我们最终的反向区域文件将如下所示:</p><pre class=""><code class="language-bash">$TTL    604800  @       IN      SOA     <span>nyc3.example.com</span>. admin.nyc3.example.com. (                                3         ; Serial                           604800         ; Refresh                            86400         ; Retry                          2419200         ; Expire                           604800 )       ; Negative Cache TTL  ; name servers        IN      NS      ns1.<span>nyc3.example.com</span>.        IN      NS      ns2.<span>nyc3.example.com</span>.    ; PTR Records  11.10   IN      PTR     ns1.<span>nyc3.example.com</span>.    ; 10.128.10.11  12.20   IN      PTR     ns2.<span>nyc3.example.com</span>.    ; 10.128.20.12  101.100 IN      PTR     <span>host1.nyc3.example.com</span>.  ; 10.128.100.101  102.200 IN      PTR     <span>host2.nyc3.example.com</span>.  ; 10.128.200.102</code></pre><h3><span class="ez-toc-section" id="Tutorial_Check_the_BIND_configuration_structure"/>教程检查绑定配置结构<span class="ez-toc-section-end"/></h3><p>运行以下命令检查<strong> named.conf * </strong>文件的结构:</p><pre class=""><code class="language-bash">sudo named-checkconf</code></pre><p>如果您的命名配置文件没有任何结构错误，您将返回到命令提示符，而不会看到任何错误。但是如果配置文件有任何问题，您应该检查错误消息并返回到本指南的“配置主DNS服务器”部分，并在修复错误后再次运行<strong> named-checkconf </strong>命令。</p><p>执行<strong> named-checkzone </strong>命令来检查区域文件的正确性。该命令的第一个参数是区域的名称，第二个参数是相应的区域文件，这两个参数都必须在<strong> named.conf.local </strong>文件中定义。</p><p>以<em><strong/></em>为例，要查看“【nyc3.example.com】”转发区的配置，运行以下命令。确保用您的服务器规格替换突出显示的项目:</p><pre class=""><code class="language-bash">sudo named-checkzone <span>nyc3.example.com</span> db.<span>nyc3.example.com</span></code></pre><p>运行以下命令检查"<strong> 128.10.in-addr.arpa </strong>"反向区域配置。更改数字以匹配您的反转区域和文件:</p><pre class=""><code class="language-bash">sudo named-checkzone <span>128.10</span>.in-addr.arpa /etc/bind/zones/db.<span>10.128</span></code></pre><p>一旦确定所有的配置文件和区域都没有错误，就可以重新启动绑定服务了。</p><h3><span class="ez-toc-section" id="How_to_restart_BIND_on_DNS_server"/>如何在DNS服务器上重启绑定<span class="ez-toc-section-end"/></h3><p>使用以下命令重新启动BIND:</p><pre class=""><code class="language-bash">sudo systemctl restart bind9</code></pre><p>如果您启用了UFW防火墙，请使用以下命令打开绑定访问:</p><pre class=""><code class="language-bash">sudo ufw allow Bind9</code></pre><p>您的主DNS服务器现在已经启动并运行，可以响应DNS查询。</p><h2><span class="ez-toc-section" id="How_to_configure_a_secondary_DNS_server"/>如何配置二级DNS服务器<span class="ez-toc-section-end"/></h2><p>在大多数情况下，设置一个在主服务器出现故障时响应查询的辅助DNS服务器是一个好主意。幸运的是，配置辅助DNS服务器要容易得多。</p><p>在<strong> ns2 </strong>服务器上打开<strong> named.conf.options </strong>文件:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/named.conf.options</code></pre><p>在文件开头，使用所有受信任服务器的私有IP地址创建一个ACL:</p><pre class=""><code class="language-bash">acl "trusted" {          <span>10.128.10.11</span>;   # ns1          <span>10.128.20.12</span>;   # ns2 - can be set to localhost          <span>10.128.100.101</span>;  # host1          <span>10.128.200.102</span>;  # host2  };    options {            . . .</code></pre><p>在目录后，添加以下命令:</p><pre class=""><code class="language-bash">        recursion yes;          allow-recursion { trusted; };          listen-on { <span>10.128.20.12</span>; };      # ns2 private IP address          allow-transfer { none; };          # disable zone transfers by default            forwarders {                  8.8.8.8;                  8.8.4.4;          };</code></pre><p><strong>保存</strong>并关闭<strong> named.conf.options </strong>文件。这个文件现在看起来应该和ns1服务器上的<strong> named.conf.options </strong>文件一模一样，除了它被配置为监听ns2私有IP地址。然后打开<strong> named.conf.local </strong>文件:</p><pre class=""><code class="language-bash">sudo nano /etc/bind/named.conf.local</code></pre><p>定义与主DNS服务器上的主区域相对应的区域。请注意，在这种情况下，类型将等于“<strong> slave </strong>”，因此文件不包含路径，并且存在必须设置为等于原始专用DNS IP地址的主目录。如果您已经在主DNS服务器上定义了几个反向区域，您应该确保将它们都添加到这里:</p><pre class=""><code class="language-bash">zone "<span>nyc3.example.com</span>" {      type slave;      file "db.<span>nyc3.example.com</span>";      masters { <span>10.128.10.11</span>; };  # ns1 private IP  };    zone "<span>128.10</span>.in-addr.arpa" {      type slave;      file "db.<span>10.128</span>";      masters { <span>10.128.10.11</span>; };  # ns1 private IP  };</code></pre><p>现在<strong>保存</strong>并关闭<strong> named.conf.local </strong>文件。运行以下命令检查配置文件:</p><pre class=""><code class="language-bash">sudo named-checkconf</code></pre><p>检查完成后，重新启动BIND:</p><pre class=""><code class="language-bash">sudo systemctl restart bind9</code></pre><p>通过如下方式更改UFW防火墙，允许DNS连接通过:</p><pre class=""><code class="language-bash">sudo ufw allow Bind9</code></pre><p>主DNS服务器和辅助DNS服务器现已配置为解析专用网络和相应的IP地址。接下来，我们将客户端服务器配置为使用私有DNS服务器。</p><h2><span class="ez-toc-section" id="Learn_how_to_configure_DNS_clients"/>了解如何配置DNS客户端<span class="ez-toc-section-end"/></h2><p>在所有被称为“可信”的ACL服务器可以查询ACL服务器之前，我们必须将它们中的每一个配置为使用<strong> ns1 </strong>和<strong> ns2 </strong>作为名称服务器。这个过程取决于操作系统的类型；但是对于大多数Linux发行版来说，它需要在<strong> etc/resolv.conf/ </strong>文件中添加名称服务器。</p><h3><span class="ez-toc-section" id="How_to_configure_Ubuntu_2004_clients"/>如何配置Ubuntu 20.04客户端<span class="ez-toc-section-end"/></h3><p>使用Netplan配置<strong> Ubuntu 20.04 </strong>操作系统上的网络，这允许您编写标准化的网络配置，并将其应用于后端网络软件。要配置DNS，我们需要编辑网络规划配置文件。</p><p>首先，通过使用ip address命令查询专用子网，找到与您的专用网络相关的目录:</p><pre class=""><code class="language-bash">ip address show to <span>10.128.0.0/16</span></code></pre><p><strong>输出:</strong></p><pre class=""><code class="language-bash">3: <span>eth1</span>: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000  inet 10.128.100.101/16 brd 10.128.255.255 scope global eth1  valid_lft forever preferred_lft forever</code></pre><p>在这个例子中，私有接口被称为<strong> eth1 </strong>。然后在<strong> etc/netplan/ </strong>中创建一个名为00-private-nameservers.yaml的文件:</p><pre class=""><code class="language-bash">sudo nano /etc/netplan/00-private-nameservers.yaml</code></pre><p>我们将以下内容放在这个文件中。</p><p><em> <strong>注意:</strong> </em>您必须更换您的专用网络接口，名为ns1和ns2的d ns服务器地址，以及您的DNS区域:</p><pre class=""><code class="language-bash">network:      version: 2      ethernets:          <span>eth1</span>:                                 # Private network interface              nameservers:                  addresses:                  - <span>10.128.10.11</span>                # Private IP for ns1                  - <span>10.132.20.12</span>                # Private IP for ns2                  search: [ <span>nyc3.example.com</span> ]  # DNS zone</code></pre><p>请注意，Netplan对其配置文件使用YAML数据序列化格式。因为YAML使用缩进和空格来定义其数据结构，所以您需要确保您的定义具有正确的缩进结构，这样就不会出现错误。</p><p>在这一步中，保存文件并退出。然后，我们必须用netplan try命令告诉Netplan尝试使用新的配置文件。如果出现导致网络中断的问题，网络计划将在一段时间后自动取消更改，并将状态恢复为:</p><pre class=""><code class="language-bash">sudo netplan try</code></pre><p><strong>输出:</strong></p><pre class=""><code class="language-bash">Warning: Stopping systemd-networkd.service, but it can still be activated by:    systemd-networkd.socket  Do you want to keep these settings?      Press ENTER before the timeout to accept the new configuration      Changes will revert in 120 seconds</code></pre><p>如果输出端的倒计时正确完成，新配置将至少运行到不会断开SSH连接的程度。按Enter键接受新配置。</p><p>现在检查系统DNS解析器，查看是否应用了DNS配置:</p><pre class=""><code class="language-bash">sudo systemd-resolve –status</code></pre><p>向下滚动查看与您的专用网络接口相关的部分。可能会首先列出DNS服务器的私有IP地址，然后准备好备用值。您的域应该出现在“DNS域”部分:</p><p><strong>输出:</strong></p><pre class=""><code class="language-bash">. . .  Link 3 (eth1)        Current Scopes: DNS         LLMNR setting: yes  MulticastDNS setting: no        DNSSEC setting: no      DNSSEC supported: no           DNS Servers: <span>10.128.10.11</span>                        <span>10.128.20.12</span>                        67.207.67.2                        67.207.67.3            DNS Domain: <span>nyc3.example.com</span>  . . .</code></pre><h2><span class="ez-toc-section" id="Conclusion"/>结论<span class="ez-toc-section-end"/></h2><p>在本文中，我们试图让你完全熟悉私有DNS服务器，并教你如何在ubuntu 20.04上设置私有DNS服务器。您现在可以使用IP地址而不是IP地址来指定您的专用网络连接。这使得配置服务和应用程序变得更容易，因为您不再需要记住它们的私有IP地址，并且文件更容易阅读和理解。此外，您现在可以将您的配置更改到一个位置，即主DNS服务器，以便它指向一个新的服务器，并且您不需要编辑不同的配置文件，这使得维护更容易。</p></div></div>    
</body>
</html>